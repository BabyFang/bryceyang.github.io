---
layout: post
tille: 正则表达式入门笔记
date: 2017-05-20 15:43:00.000000000 +09:00
category: Linux
tag: Linux
---

#### [正则表达式入门](https://deerchao.net/tutorials/regex/regex.htm)

* * * * *

**1. 元字符 metacharater**

> **\b**,代表着单词的开头或者结尾，也就是单词的分界处；
>
> **.** 匹配除了换行符以外的任意字符；
>
> **\d** 匹配一位数字；
>
> **\s** 匹配任意的空白符，包括空格，制表符，换行符，中文全角空格等；
>
> **\w** 匹配字母或数字或下划线或者汉字等；
>
> **^**  匹配字符串的开始；
>
> **$**  匹配字符串的结束；

* * * * *
 **字符转义仍然是使用\**
 
 
* * * * *

**2. 限定**
> **+** 指定前面的内容可以连续重复1次或者更多次；
>
> **/*** 指定前面的内容可以连续重复任意次（包括0次)；
>
> **?** 重复零次或者一次；
>
> **{n}** 重复n次；
>
> **{n,1}** 重复n次或者更多次；
>
> **{n,m}** 重复n次到m次；

* * * * *

**3. 字符类** 

*可以利用方括号来匹配所需字符，[acb]代表可以匹配abc其中的一个，所以**[]只用来匹配没有元字符对应的字符集中的单个字符*** 

> 比如[0-9],就跟\d是完全一致的，也就是匹配单个数字



* * * * *



**4.分支条件**


> 正则表达式分支条件示例：\d{5}-\d{4}|\d{5}
>
> 这个例子含有一个小的tricky的地方，就是它说明了一个问题：
> **用分支条件时，要注意各个条件的顺序**。如果把这个表达式改为**\d{5}|\d{5}-\d{4}**，
> 那么就只会匹配五位的邮编以及9位邮编的前5位。
>
> **原因是匹配分支条件时，将会从左到右地测试每个条件，如果满足了某个分支的话，就不会再管其它条件。** 


* * * * *

**5. 分组**
*上面所说的都是重复单个字符的方法，如果想要重复多个字符可以用小括号来指定子表达式（也叫作分组），这也是当我们需要（字符本身时需要对其进行转义的原因。*

* * *

**6.反义**


|代码语法|说明                                       |
|--------|:-----------------------------------------:|
|\W      | 匹配任意不是字母、数字、下划线、汉字的字符|
|\S      | 匹配任意不是空白符的字符                  |
|\D      | 匹配任意非数字的字符                      |
|\B      | 匹配不是单词开头或结束的位置              |
|[^x]    | 匹配除了x以外的任意字符                   |
|[^aeiou]| 匹配除了aeiou这几个字母以外的任意字符     |


* * *

**7.后向引用**

使用小括号指定一个子表达式后，匹配这个子表达式的文本
